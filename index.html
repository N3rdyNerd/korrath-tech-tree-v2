<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Korrath Tech Tree</title>
  <style>
    :root {
      --bg: #0b0b12;
      --panel: #141421;
      --card: #1b1b2e;
      --accent: #9a4dff;
      --accent-2: #35c0ff;
      --good: #38d39f;
      --warn: #ffb020;
      --bad: #ff5b6e;
      --text: #e9e9f4;
      --muted: #9aa0b3;
      --grid-gap: 20px;
      --tier-width: 320px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 15% -10%, #17172b 0%, var(--bg) 50%), var(--bg);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }
    .app { display: grid; grid-template-columns: 280px 1fr; height: 100%; }
    aside {
      background: linear-gradient(180deg, #11111b 0%, #0f0f18 100%);
      border-right: 1px solid #22223a; padding: 16px; overflow: auto;
    }
    main { position: relative; overflow: hidden; }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      padding: 12px 16px; border-bottom: 1px solid #22223a; background: #10101a; position: sticky; top: 0; z-index: 3;
    }
    header .title { font-weight: 700; letter-spacing: .5px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    button, select { background: var(--panel); color: var(--text); border: 1px solid #2a2a44; padding: 8px 10px; border-radius: 10px; cursor: pointer; }
    button:hover { border-color: var(--accent); }
    .badge { padding: 6px 10px; border-radius: 999px; background: #141428; border: 1px solid #2a2a44; font-size: 12px; }
    .badge .num { font-weight: 700; color: var(--good); }

    /* Sidebar */
    .sidebar-section { margin-bottom: 18px; }
    .sidebar-section h3 { margin: 10px 0 8px; color: var(--accent-2); font-size: 14px; letter-spacing: .6px; text-transform: uppercase; }
    .mode-toggle { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .mode-toggle button.active { background: linear-gradient(180deg, #2a1f4a, #1e1636); border-color: var(--accent); }
    .counter { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .kvar { display: grid; gap: 8px; }
    .kvar label { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    .kvar input, .kvar select { background: var(--card); border: 1px solid #2a2a44; color: var(--text); padding: 8px 10px; border-radius: 10px; }

    /* Canvas */
    .canvas-wrap { position: absolute; inset: 0; overflow: auto; }
    .canvas { position: relative; width: max(1200px, 100%); height: max(1100px, 100%); padding: 30px 40px; }

    .grid { position: relative; display: grid; grid-auto-flow: column; grid-auto-columns: var(--tier-width); gap: var(--grid-gap); }
    .tier-col { position: relative; padding-top: 30px; }
    .tier-label { position: sticky; top: 60px; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .6px; margin-bottom: 8px; }

    .node-col { display: grid; gap: 16px; }
    .node {
      position: relative; padding: 12px; border-radius: 14px; background: linear-gradient(180deg, #1a1a2b 0%, #151527 100%);
      border: 1px solid #242446; box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    .node .name { font-weight: 700; margin-bottom: 6px; }
    .node .desc { font-size: 13px; color: var(--muted); margin-bottom: 8px; }
    .node .meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .node .tag { font-size: 11px; padding: 4px 8px; border: 1px solid #2a2a44; border-radius: 999px; color: var(--muted); }
    .node .cost { font-size: 12px; }
    .node button { width: 100%; margin-top: 8px; background: #17172b; }

    .node.locked { opacity: .75; }
    .node.unlockable { outline: 2px solid var(--accent); }
    .node.unlocked { border-color: rgba(56, 211, 159, .6); box-shadow: 0 0 0 1px rgba(56, 211, 159, .3), inset 0 0 0 1px rgba(56,211,159,.1); }

    .legend { display: flex; gap: 8px; align-items: center; }
    .legend .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--muted); margin-right: 6px; display: inline-block; }
    .legend .dot.unlockable { background: var(--accent); }
    .legend .dot.unlocked { background: var(--good); }

    /* Edge layer */
    svg.edges { position: absolute; inset: 0; pointer-events: none; }
    .edge { stroke: #3e3e66; stroke-width: 2; opacity: .7; }
    .edge.active { stroke: var(--accent); opacity: .9; }
    .edge.done { stroke: var(--good); opacity: 1; }

    .footer { position: sticky; bottom: 0; padding: 10px 16px; background: #0e0e18; border-top: 1px solid #22223a; display: flex; gap: 8px; justify-content: flex-end; }
  </style>
  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="app">
    <aside>
      <div class="sidebar-section">
        <h2 style="margin:4px 0 12px">Korrath Tech Tree</h2>
        <div class="mode-toggle">
          <button id="btnGroup" class="active">Group Tree</button>
          <button id="btnPersonal">Personal Tree</button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Points</h3>
        <div class="counter">
          <div class="badge">Group Pts: <span class="num" id="groupPts">0</span></div>
          <div class="badge">Personal Pts: <span class="num" id="personalPts">0</span></div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Campaign State</h3>
        <div class="kvar">
          <label>Party Level
            <input id="partyLevel" type="number" min="1" max="20" value="1" />
          </label>
          <label>Max Tier (auto from level)
            <input id="maxTier" type="number" min="1" max="10" value="1" />
          </label>
          <label>Branch Filter
            <select id="branchFilter">
              <option value="all" selected>All</option>
            </select>
          </label>
          <button id="btnRecalc">Recalculate Unlockables</button>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Data</h3>
        <div class="kvar">
          <label>Campaign ID
            <input id="campaignId" placeholder="uuid" />
          </label>
          <label>Character ID
            <input id="characterId" placeholder="uuid (optional for players)" />
          </label>
          <button id="btnGMLogin">GM Login (PIN)</button>
          <button id="btnClaimChar">Claim/Create Character</button>
          <button id="btnSave">Save to Local</button>
          <button id="btnLoad">Load from Local</button>
          <button id="btnExport">Export JSON</button>
          <input id="importFile" type="file" accept="application/json" />
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Legend</h3>
        <div class="legend">
          <span class="dot"></span> Locked
          <span class="dot unlockable"></span> Unlockable
          <span class="dot unlocked"></span> Unlocked
        </div>
      </div>

      <div class="sidebar-section" style="margin-top:20px; font-size:12px; color:var(--muted)">
        <div><strong>Tip:</strong> Tier 1 should align to level 1–2 milestones. Adjust the level→tier rule below if you want a slower/faster ramp.</div>
      </div>

      <div class="sidebar-section" style="margin-top:14px">
        <h3>Reset</h3>
        <button id="btnReset">Reset Tree (This Mode)</button>
      </div>
    </aside>

    <main>
      <header>
        <div class="title">Mode: <span id="modeLabel">Group</span></div>
        <div class="controls">
          <button id="btnAddGroupPts">+1 Group Pt</button>
          <button id="btnAddPersonalPts">+1 Personal Pt</button>
          <select id="zoom">
            <option value="0.8">Zoom 80%</option>
            <option value="1" selected>Zoom 100%</option>
            <option value="1.2">Zoom 120%</option>
            <option value="1.4">Zoom 140%</option>
          </select>
        </div>
      </header>

      <div class="canvas-wrap" id="canvasWrap">
        <div class="canvas" id="canvas">
          <svg class="edges" id="edgeLayer"></svg>
          <div class="grid" id="grid"></div>
        </div>
      </div>

      <div class="footer">
        <button id="btnSupabaseSync">Supabase: Connected</button>
      </div>
    </main>
  </div>

  <script>
    /*************************************************
     * CONFIG
     *************************************************/
    const STATE = {
      mode: 'group',
      points: { group: 0, personal: 0 },
      partyLevel: 1,
      maxTier: 1,
      unlocked: { group: new Set(), personal: new Set() },
      zoom: 1,
      branch: 'all',
      sb: null,
      campaignId: null,
      characterId: null,
      isGM: false
    };

    // Level → Max Tier rule. Tune as desired.
    function levelToTier(level) {
      if (level <= 2) return 1; // 1–2
      if (level <= 4) return 2; // 3–4
      if (level <= 6) return 3; // 5–6
      if (level <= 9) return 4; // 7–9
      if (level <= 12) return 5; // 10–12
      if (level <= 15) return 6; // 13–15
      if (level <= 18) return 7; // 16–18
      return 8; // 19–20
    }

    // SAMPLE DATA — swap in your own.
    // Loaded from Supabase at runtime
let TECH_DATA = [];
const REQS = new Map(); // id -> [reqIds]

async function loadTech() {
  if (!STATE.sb) return;
  const { data: nodes, error } = await STATE.sb
    .from('tech_nodes')
    .select('id,type,tier,cost,branch,name,descr,max_instances');
  if (error) { console.error(error); alert('Failed to load tech nodes'); return; }
  const { data: reqs, error: e2 } = await STATE.sb
    .from('tech_reqs')
    .select('node_id,req_id');
  if (e2) { console.error(e2); alert('Failed to load prerequisites'); return; }

  REQS.clear();
  (reqs || []).forEach(r => {
    if (!REQS.has(r.node_id)) REQS.set(r.node_id, []);
    REQS.get(r.node_id).push(r.req_id);
  });

  TECH_DATA = (nodes || []).map(n => ({
    id: n.id,
    type: n.type,
    tier: n.tier,
    name: n.name,
    cost: n.cost,
    branch: n.branch,
    desc: n.descr,
    max: n.max_instances,
    req: REQS.get(n.id) || []
  }));

  updateBranchOptions();
  render();
}

    /*************************************************
     * RENDERING
     *************************************************/
    const gridEl = document.getElementById('grid');
    const edgeLayer = document.getElementById('edgeLayer');

    function branchesFor(mode) {
      const set = new Set();
      TECH_DATA.filter(n => n.type === mode).forEach(n => set.add(n.branch));
      return Array.from(set).sort();
    }

    function tiersFor(mode) {
      const set = new Set();
      TECH_DATA.filter(n => n.type === mode).forEach(n => set.add(n.tier));
      return Array.from(set).sort((a,b)=>a-b);
    }

    function currentUnlockedSet() { return STATE.unlocked[STATE.mode]; }

    function nodeState(node) {
      const unlocked = currentUnlockedSet().has(node.id);
      if (unlocked) return 'unlocked';
      if (STATE.branch !== 'all' && node.branch !== STATE.branch) return 'locked';
      if (node.tier > STATE.maxTier) return 'locked';
      const reqOk = (node.req || []).every(id => currentUnlockedSet().has(id));
      if (!reqOk) return 'locked';
      const pool = STATE.mode === 'group' ? STATE.points.group : STATE.points.personal;
      if (pool >= node.cost) return 'unlockable';
      return 'locked';
    }

    function render() {
      gridEl.innerHTML = '';
      const tiers = tiersFor(STATE.mode);
      const filteredNodes = TECH_DATA.filter(n => n.type === STATE.mode && (STATE.branch === 'all' || n.branch === STATE.branch));
      const byTier = new Map();
      tiers.forEach(t => byTier.set(t, []));
      filteredNodes.forEach(n => byTier.get(n.tier).push(n));

      for (const [t, arr] of byTier) {
        arr.sort((a,b)=> a.branch.localeCompare(b.branch) || a.name.localeCompare(b.name));
      }

      for (const t of tiers) {
        const col = document.createElement('div');
        col.className = 'tier-col';
        const label = document.createElement('div');
        label.className = 'tier-label';
        label.textContent = `Tier ${t}`;
        col.appendChild(label);

        const nc = document.createElement('div');
        nc.className = 'node-col';
        (byTier.get(t) || []).forEach(node => nc.appendChild(renderNode(node)));
        col.appendChild(nc);
        gridEl.appendChild(col);
      }

      requestAnimationFrame(drawEdges);

      document.getElementById('groupPts').textContent = STATE.points.group;
      document.getElementById('personalPts').textContent = STATE.points.personal;
      document.getElementById('modeLabel').textContent = STATE.mode === 'group' ? 'Group' : 'Personal';
    }

    function renderNode(node) {
      const div = document.createElement('div');
      div.className = `node ${nodeState(node)}`;
      div.dataset.nodeId = node.id;
      div.innerHTML = `
        <div class="name">${node.name}</div>
        <div class="desc">${node.desc}</div>
        <div class="meta">
          <span class="tag">Tier ${node.tier}</span>
          <span class="tag">${node.branch}</span>
          <span class="tag cost">Cost: ${node.cost}</span>
        </div>
      `;
      if (!currentUnlockedSet().has(node.id)) {
        const btn = document.createElement('button');
        btn.textContent = 'Unlock';
        btn.addEventListener('click', () => tryUnlock(node));
        div.appendChild(btn);
      } else {
        const tag = document.createElement('div');
        tag.className = 'tag';
        tag.style.marginTop = '8px';
        tag.textContent = 'Unlocked';
        div.appendChild(tag);
      }
      return div;
    }

    function findNodeEl(id) { return document.querySelector(`[data-node-id="${id}"]`); }

    function drawEdges() {
      edgeLayer.innerHTML = '';
      const nodes = TECH_DATA.filter(n => n.type === STATE.mode && (STATE.branch === 'all' || n.branch === STATE.branch));
      const unlocked = currentUnlockedSet();
      nodes.forEach(n => {
        (n.req || []).forEach(reqId => {
          const fromEl = findNodeEl(reqId);
          const toEl   = findNodeEl(n.id);
          if (!fromEl || !toEl) return;
          const f = fromEl.getBoundingClientRect();
          const t = toEl.getBoundingClientRect();
          const wrap = document.getElementById('canvas').getBoundingClientRect();
          const x1 = (f.right - wrap.left);
          const y1 = (f.top + f.height/2 - wrap.top);
          const x2 = (t.left - wrap.left);
          const y2 = (t.top + t.height/2 - wrap.top);
          const path = makeBezier(x1, y1, x2, y2);
          const edge = document.createElementNS('http://www.w3.org/2000/svg','path');
          edge.setAttribute('d', path);
          edge.setAttribute('fill','none');
          edge.setAttribute('class','edge ' + (unlocked.has(n.id) ? 'done' : nodeState(n) === 'unlockable' ? 'active' : ''));
          edgeLayer.appendChild(edge);
        });
      });
    }

    function makeBezier(x1,y1,x2,y2) {
      const dx = Math.max(40, (x2 - x1) * 0.5);
      const c1x = x1 + dx, c1y = y1;
      const c2x = x2 - dx, c2y = y2;
      return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
    }

    /*************************************************
     * GAME LOGIC
     *************************************************/
    function tryUnlock(node) {
      const poolKey = STATE.mode === 'group' ? 'group' : 'personal';
      const pool = STATE.points[poolKey];
      if (node.tier > STATE.maxTier) return alert('Tier is gated by party level.');
      const reqOk = (node.req || []).every(id => currentUnlockedSet().has(id));
      if (!reqOk) return alert('Prerequisites not met.');
      if (pool < node.cost) return alert('Not enough points.');

      if (STATE && STATE.sb) {
        const targetType = STATE.mode === 'group' ? 'campaign' : 'character';
        const targetId = STATE.mode === 'group' ? STATE.campaignId : STATE.characterId;
        if (!targetId) return alert('Set Campaign/Character first.');
        rpcUnlockNode(targetType, targetId, node.id);
        return;
      }

      STATE.points[poolKey] -= node.cost;
      currentUnlockedSet().add(node.id);
      render();
    }

    function recalcMaxTierFromLevel() {
      const lvl = Number(document.getElementById('partyLevel').value || 1);
      STATE.partyLevel = lvl;
      STATE.maxTier = levelToTier(lvl);
      document.getElementById('maxTier').value = STATE.maxTier;
    }

    function manualSetMaxTier() {
      STATE.maxTier = Number(document.getElementById('maxTier').value || 1);
    }

    function updateBranchOptions() {
      const select = document.getElementById('branchFilter');
      const list = branchesFor(STATE.mode);
      select.innerHTML = '<option value="all">All</option>' + list.map(b=>`<option value="${b}">${b}</option>`).join('');
    }

    /*************************************************
     * PERSISTENCE (LOCAL)
     *************************************************/
    const STORAGE_KEY = 'korrath-tech-tree-v1';
    function saveLocal() {
      const payload = {
        points: STATE.points,
        partyLevel: STATE.partyLevel,
        maxTier: STATE.maxTier,
        unlocked: {
          group: Array.from(STATE.unlocked.group),
          personal: Array.from(STATE.unlocked.personal)
        }
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      alert('Saved.');
    }

    function loadLocal() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return alert('No saved state.');
      try {
        const data = JSON.parse(raw);
        STATE.points = data.points || {group:0, personal:0};
        STATE.partyLevel = data.partyLevel || 1;
        STATE.maxTier = data.maxTier || levelToTier(STATE.partyLevel);
        STATE.unlocked.group = new Set(data.unlocked?.group || []);
        STATE.unlocked.personal = new Set(data.unlocked?.personal || []);
        document.getElementById('partyLevel').value = STATE.partyLevel;
        document.getElementById('maxTier').value = STATE.maxTier;
        render();
      } catch (e) { alert('Bad save payload.'); }
    }

    function exportJSON() {
      const blob = new Blob([JSON.stringify({ TECH_DATA, STATE: serializableState() }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'korrath-tech-tree.json'; a.click();
      URL.revokeObjectURL(url);
    }

    function serializableState() {
      return {
        mode: STATE.mode,
        points: STATE.points,
        partyLevel: STATE.partyLevel,
        maxTier: STATE.maxTier,
        unlocked: {
          group: Array.from(STATE.unlocked.group),
          personal: Array.from(STATE.unlocked.personal)
        },
        branch: STATE.branch,
        zoom: STATE.zoom
      };
    }

    function importJSON(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const payload = JSON.parse(reader.result);
          if (payload.STATE) {
            const s = payload.STATE;
            STATE.points = s.points || STATE.points;
            STATE.partyLevel = s.partyLevel || STATE.partyLevel;
            STATE.maxTier = s.maxTier || STATE.maxTier;
            STATE.branch = s.branch || 'all';
            STATE.zoom = s.zoom || 1;
            STATE.unlocked.group = new Set(s.unlocked?.group || []);
            STATE.unlocked.personal = new Set(s.unlocked?.personal || []);
            document.getElementById('partyLevel').value = STATE.partyLevel;
            document.getElementById('maxTier').value = STATE.maxTier;
          }
          render();
        } catch (e) { alert('Import failed: ' + e.message); }
      };
      reader.readAsText(file);
    }

    /*************************************************
     * SUPABASE (wired)
     *************************************************/
    const SUPABASE_URL = 'https://xwbekwtawoeavjalknle.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh3YmVrd3Rhd29lYXZqYWxrbmxlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ3MTIyNjUsImV4cCI6MjA3MDI4ODI2NX0.47twH1UqRqaOriKWY-tOWNz40ntLR5q8IXq1icLe6bw';

    async function supabaseInit() {
      STATE.sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      const { data: { user }, error } = await STATE.sb.auth.signInAnonymously();
      if (error) { console.error(error); alert('Supabase anon auth failed'); }
      else console.log('Supabase anon user', user?.id);
    }

    async function gmLogin() {
      const campaignId = (document.getElementById('campaignId').value || '').trim();
      if (!campaignId) return alert('Enter Campaign ID first.');
      const pin = prompt('Enter GM PIN for this campaign');
      if (!pin) return;
      const { error } = await STATE.sb.rpc('claim_campaign', { gm_pin: pin, p_campaign_id: campaignId });
      if (error) { alert('GM claim failed: ' + error.message); return; }
      STATE.campaignId = campaignId;
      STATE.isGM = true;
      await refreshGroupPoints();
      await refreshProgress('campaign', campaignId);
      alert('GM mode unlocked for this session.');
    }

    async function claimOrCreateCharacter() {
      const campaignId = (document.getElementById('campaignId').value || '').trim();
      if (!campaignId) return alert('Enter Campaign ID first.');
      let charId = (document.getElementById('characterId').value || '').trim();
      const code = prompt(charId ? 'Enter your character code to claim' : 'Set a new character code');
      if (!code) return;
      if (!charId) {
        const name = prompt('Character name?');
        if (!name) return;
        const { data, error } = await STATE.sb.rpc('create_character_with_code', { p_campaign_id: campaignId, p_name: name, p_owner_code: code });
        if (error) { alert('Create failed: ' + error.message); return; }
        charId = data?.id;
        document.getElementById('characterId').value = charId || '';
      }
      const { error } = await STATE.sb.rpc('claim_character', { owner_code: code, p_character_id: charId });
      if (error) { alert('Claim failed: ' + error.message); return; }
      STATE.campaignId = campaignId;
      STATE.characterId = charId;
      await refreshPersonalPoints();
      await refreshProgress('character', charId);
      alert('Character claimed to this device.');
    }

    async function rpcUnlockNode(targetType, targetId, nodeId) {
      const { error } = await STATE.sb.rpc('unlock_node', { target_type: targetType, p_target_id: targetId, p_node_id: nodeId });
      if (error) { alert('Unlock failed: ' + error.message); return false; }
      if (targetType === 'campaign') await refreshGroupPoints(); else await refreshPersonalPoints();
      await refreshProgress(targetType, targetId);
      return true;
    }

    async function refreshGroupPoints() {
      if (!STATE.campaignId) return;
      const { data, error } = await STATE.sb.from('campaigns').select('group_points').eq('id', STATE.campaignId).single();
      if (!error) { STATE.points.group = data.group_points; render(); }
    }
    async function refreshPersonalPoints() {
      if (!STATE.characterId) return;
      const { data, error } = await STATE.sb.from('characters').select('personal_points').eq('id', STATE.characterId).single();
      if (!error) { STATE.points.personal = data.personal_points; render(); }
    }
    async function refreshProgress(targetType, targetId) {
      const { data, error } = await STATE.sb.from('progress').select('node_id').eq('target_type', targetType).eq('target_id', targetId);
      if (error) return;
      const ids = new Set(data.map(r => r.node_id));
      const set = targetType === 'campaign' ? STATE.unlocked.group : STATE.unlocked.personal;
      set.clear(); ids.forEach(id => set.add(id));
      render();
    }

    /*************************************************
     * EVENTS
     *************************************************/
    function init() {
      document.getElementById('btnGroup').onclick = () => { STATE.mode = 'group'; setModeButton(); updateBranchOptions(); render(); };
      document.getElementById('btnPersonal').onclick = () => { STATE.mode = 'personal'; setModeButton(); updateBranchOptions(); render(); };

      document.getElementById('btnAddGroupPts').onclick = async () => {
        if (STATE.sb && STATE.campaignId) {
          const { data, error } = await STATE.sb.rpc('add_group_points', { p_campaign_id: STATE.campaignId, delta: 1 });
          if (error) return alert(error.message);
          STATE.points.group = data; render();
        } else { STATE.points.group++; render(); }
      };
      document.getElementById('btnAddPersonalPts').onclick = async () => {
        if (STATE.sb && STATE.characterId) {
          const { data, error } = await STATE.sb.rpc('add_personal_points', { p_character_id: STATE.characterId, delta: 1 });
          if (error) return alert(error.message);
          STATE.points.personal = data; render();
        } else { STATE.points.personal++; render(); }
      };

      document.getElementById('partyLevel').oninput = () => { recalcMaxTierFromLevel(); render(); };
      document.getElementById('maxTier').oninput = () => { manualSetMaxTier(); render(); };
      document.getElementById('branchFilter').onchange = (e) => { STATE.branch = e.target.value; render(); };
      document.getElementById('btnRecalc').onclick = () => { recalcMaxTierFromLevel(); render(); };

      document.getElementById('btnSave').onclick = saveLocal;
      document.getElementById('btnLoad').onclick = loadLocal;
      document.getElementById('btnExport').onclick = exportJSON;
      document.getElementById('importFile').onchange = (e) => { if (e.target.files?.[0]) importJSON(e.target.files[0]); };
      document.getElementById('btnReset').onclick = () => { if (!confirm('Reset unlocked nodes for this mode?')) return; STATE.unlocked[STATE.mode] = new Set(); render(); };
      document.getElementById('btnSupabaseSync').onclick = () => alert('Supabase live mode enabled — use GM/Character controls above.');

      document.getElementById('zoom').onchange = (e) => {
        STATE.zoom = parseFloat(e.target.value);
        document.getElementById('canvas').style.transform = `scale(${STATE.zoom})`;
        document.getElementById('canvas').style.transformOrigin = '0 0';
        requestAnimationFrame(drawEdges);
      };

      recalcMaxTierFromLevel();
      setModeButton();
      updateBranchOptions();
      render();

      const wrap = document.getElementById('canvasWrap');
      wrap.addEventListener('scroll', () => requestAnimationFrame(drawEdges));
      window.addEventListener('resize', () => requestAnimationFrame(drawEdges));
    }

    function setModeButton() {
      document.getElementById('btnGroup').classList.toggle('active', STATE.mode==='group');
      document.getElementById('btnPersonal').classList.toggle('active', STATE.mode==='personal');
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await supabaseInit();
      await loadTech();
      init();
      document.getElementById('btnGMLogin').onclick = gmLogin;
      document.getElementById('btnClaimChar').onclick = claimOrCreateCharacter;
    });
  </script>
</body>
</html>
